/*https://www.acmicpc.net/problem/11053*/
// dp문제
// 수열이 주어졌을때 가장 긴 증가하는 부분을 찾는 문제
// 입력받을 배열 1개와 증가하는 부분수열의 길이를 저장할 배열 1개를 선언한다.
// 풀이는 간단하다 수열의 특정한 원소를 지정했으면 그 앞으로의 모든 수들을 체크해서 자기 보다 작은 수를 만나면 + 1을 해주는 것이다.
// 물론 dp로 풀이하였기 때문에 앞에서부터 증가하는 부분 수열의 길이를 누적해서 배열에 넣어준다.

#include <iostream>

using namespace std;

int arr[1001];
int arr2[1001];

int main(void)
{
	int N, m = 0;
	cin >> N;
	for (int i = 0; i < N; i++)
	{
		cin >> arr[i];
	}

	for (int i = 0; i < N; i++)
	{
		arr2[i] = 1; // 가장 긴 증가하는 부분 수열의 길이는 최소 1이다.
		for (int j = 0; j < i; j++)
		{
			if (arr[j] < arr[i])
			{
				arr2[i] = max(arr2[j] + 1, arr2[i]); 
			}
		}
	}
	// 처음에 31번째줄에 arr2[i] = arr2[j] + 1이라고 해서 어려움을 겪었다.
	// max(arr2[i] + 1, arr2[i])라고 한 이유는 ex) 1,2,3,2,4에서 arr2에 만들어지는 배열은 (1,2,3,2,4)가 아니라(1,2,3,2,3)이 만들어진다/
	// 그 이유는 arr2[j] + 1이라고 하면 그 전까지는 가장 긴 부분수열의 전 값에서 +1을 더하는 것이 아니라 바로 앞 원소 값에 +1을 하므로 풀이에 틀리게 된다.
	// 그래서 특정 원소의 앞 선 원소들의(물론 특정 원소보다 값이 작아야한다) 가장 긴 부분수열의 길이에서 +1을 해주는 것이므로 max로 구분해줘야 한다.
	for (int i = 0; i < N; i++)
	{
		m = max(m, arr2[i]);
	}
	cout << m << "\n";
	return 0;
}